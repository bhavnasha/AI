# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bW4WVzpfdgLYFJfQqdyVuGAFwtEdnZqs
"""

import heapq
from collections import deque

class GridNavigation:
    def __init__(self, grid, start, goals, exit_point):
        self.grid = grid
        self.start = start
        self.goals = goals  # Dictionary {goal_position: cost}
        self.exit = exit_point
        self.rows = len(grid)
        self.cols = len(grid[0])
        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right

    def is_valid(self, x, y):
        return 0 <= x < self.rows and 0 <= y < self.cols and self.grid[x][y] != '#'

    def bfs(self):
        queue = deque([(self.start, 0)])
        visited = set()
        visited.add(self.start)
        while queue:
            (x, y), cost = queue.popleft()
            if (x, y) == self.exit:
                return cost
            for dx, dy in self.directions:
                nx, ny = x + dx, y + dy
                if self.is_valid(nx, ny) and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    queue.append(((nx, ny), cost + 1))
        return float('inf')

    def dfs(self):
        stack = [(self.start, 0)]
        visited = set()
        visited.add(self.start)
        while stack:
            (x, y), cost = stack.pop()
            if (x, y) == self.exit:
                return cost
            for dx, dy in self.directions:
                nx, ny = x + dx, y + dy
                if self.is_valid(nx, ny) and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    stack.append(((nx, ny), cost + 1))
        return float('inf')

    def uniform_cost_search(self):
        pq = [(0, self.start)]  # (cost, position)
        visited = {}
        visited[self.start] = 0
        while pq:
            cost, (x, y) = heapq.heappop(pq)
            if (x, y) == self.exit:
                return cost
            for dx, dy in self.directions:
                nx, ny = x + dx, y + dy
                new_cost = cost + self.goals.get((nx, ny), 1)
                if self.is_valid(nx, ny) and ((nx, ny) not in visited or new_cost < visited[(nx, ny)]):
                    visited[(nx, ny)] = new_cost
                    heapq.heappush(pq, (new_cost, (nx, ny)))
        return float('inf')

    def heuristic(self, pos):
        x, y = pos
        ex, ey = self.exit
        return abs(x - ex) + abs(y - ey)

    def a_star_search(self):
        pq = [(self.heuristic(self.start), 0, self.start)]  # (heuristic + cost, cost, position)
        visited = {}
        visited[self.start] = 0
        while pq:
            _, cost, (x, y) = heapq.heappop(pq)
            if (x, y) == self.exit:
                return cost
            for dx, dy in self.directions:
                nx, ny = x + dx, y + dy
                new_cost = cost + self.goals.get((nx, ny), 1)
                if self.is_valid(nx, ny) and ((nx, ny) not in visited or new_cost < visited[(nx, ny)]):
                    visited[(nx, ny)] = new_cost
                    heapq.heappush(pq, (new_cost + self.heuristic((nx, ny)), new_cost, (nx, ny)))
        return float('inf')

# Example usage
grid = [
    ['S', '.', '.', '#', 'G'],
    ['.', '#', '.', '.', '.'],
    ['.', '.', '#', '.', 'E']
]
start = (0, 0)
goals = {(0, 4): 5}  # Goal with priority (cost of 5)
exit_point = (2, 4)

nav = GridNavigation(grid, start, goals, exit_point)
print("BFS Path Cost:", nav.bfs())
print("DFS Path Cost:", nav.dfs())
print("UCS Path Cost:", nav.uniform_cost_search())
print("A* Path Cost:", nav.a_star_search())